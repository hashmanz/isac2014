
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0054)http://www.btinternet.com/~kburnett/kepler/jsmoon.html -->
<HTML><HEAD><TITLE>Approximate Moon physical ephemeris in Javascript</TITLE>
<META content="text/html; charset=windows-1252" http-equiv=Content-Type>
<SCRIPT language=JavaScript>
<!-- Hide the code from non-compliant browsers.
//
// This code was developed to calculate the Moon and Sun Gravity at any Point
// This involved modifying and developing existing code and formulas from the following links .
// Reference: http://www.dept.aoe.vt.edu/~lutze/AOE4134/13LocalSiderealTime.pdf
// http://www.bogan.ca/astro/telescopes/coodcvtn.html
// http://www.lunar-occultations.com/rlo/ephemeris.htm - developed by Keith Burnett

   	function doCalcs(form) {
   	var g, days,t ,L1, M1, C1, V1, Ec1, R1, Th1, Om1, Lam1, Obl, Ra1, Dec1;
	var F, L2, Om2, M2, D, R2, R3, Bm, Lm, HLm, HBm, Ra2, Dec2, EL, EB, W, X, Y, A; 
	var Co, SLt, Psi, Il, K, P1, P2, y, m, d, bit, h, min, bk;
	var Lat, Long, LatRaw, LongRaw, MajorAxis, MinorAxis, WGSHeight, XEllipse, YEllipse, RadiusEarth
	var JD, Tut1, UT, LocSidTime, UTSidModTime, UTSidTime, LocHourAngleMoon, LocHourAngleSun, SineAltitudeMoon, SineAltitudeSun, JuDay
	var EARTHTOMOON, MASSMOON, GCONST, aQuad, bQuad, cQuad, DistMoon, EARTHTOSUN, MASSSUN
	var GrossForceMoon, NormalForceMoon, GrossForceSun, NormalForceSun
//
//	Get date and time code from user, isolate the year, month, day and hours
//	and minutes, and do some basic error checking! This only works for AD years
//  
	g = form.num.value;
	y = Math.floor(g / 10000);
	m = Math.floor( (g - y*10000) / 100);
	d = Math.floor(g - y*10000 - m*100 );
	bit = (g - Math.floor(g))*100;
	h = Math.floor(bit);
	min = Math.floor(bit*100 - h * 100 + 0.5);
	
	//  var rightNow;
	//	rightNow = new Date();
	//	y = rightNow.getUTCFullYear();
	//	m = rightNow.getUTCMonth() + 1;
	//	d = rightNow.getUTCDate();
	//	h = rightNow.getUTCHours();
	//	min = rightNow.getUTCMinutes();
	
//
//	primative error checking - accounting for right number of
//	days per month including leap years. Using bk variable to 
//	prevent multiple alerts. See functions isleap(y) 
//	and goodmonthday(y, m, d).
//
	bk = 0;
	if(g < 16000000) {	
		bk = 1;
		alert("Routines are not accurate enough to work back that" + 
               " far - answers are meaningless!");
		}
	if(g > 23000000) {
		bk = 1;	
		alert("Routines are not accurate enough to work far into the future" + 
               " - answers are meaningless!");
		}	
	if( ((m<1) || (m>12)) && (bk !=1)) {
			bk = 1;
			alert("Months are not right - type date again");
			}
	if((goodmonthday(y, m, d) ==0) && (bk !=1)) {
			bk = 1;
			alert("Wrong number of days for the month or not a leap year - type date again");
			}
	if ((h>23) && (bk != 1)) {
			bk = 1;
			alert("Hours are not right - type date again");
			}
	if((min>59) && (bk !=1)) {
			alert("Minutes are not right - type date again");
			}
//
//	Get the number of days since J2000.0 using day2000() function
//
    days = day2000(y, m, d, h + min/60);
	t = days / 36525;

//
//	Sun formulas
//
//	L1	- Mean longitude
//	M1	- Mean anomaly
//	C1	- Equation of centre
//	V1	- True anomaly
//	Ec1	- Eccentricity 
//	R1	- Sun distance
//	Th1	- Theta (true longitude)
//	Om1	- Long Asc Node (Omega)
//	Lam1- Lambda (apparent longitude)
//	Obl	- Obliquity of ecliptic
//	Ra1	- Right Ascension
//	Dec1- Declination
//

	L1 = range(280.466 + 36000.8 * t);
	M1 = range(357.529+35999*t - 0.0001536* t*t + t*t*t/24490000);
	C1 = (1.915 - 0.004817* t - 0.000014* t * t)* dsin(M1);	 
	C1 = C1 + (0.01999 - 0.000101 * t)* dsin(2*M1);
	C1 = C1 + 0.00029 * dsin(3*M1);
	V1 = M1 + C1;
	Ec1 = 0.01671 - 0.00004204 * t - 0.0000001236 * t*t;
	R1 = 0.99972 / (1 + Ec1 * dcos(V1));
	Th1 = L1 + C1;
	Om1 = range(125.04 - 1934.1 * t);
	Lam1 = Th1 - 0.00569 - 0.00478 * dsin(Om1);
	Obl = (84381.448 - 46.815 * t)/3600;
	Ra1 = datan2(dsin(Th1) * dcos(Obl) - dtan(0)* dsin(Obl), dcos(Th1));
	Dec1 = dasin(dsin(0)* dcos(Obl) + dcos(0)*dsin(Obl)*dsin(Th1));

//
//	Moon formulas
//
//	F 	- Argument of latitude (F)
//	L2 	- Mean longitude (L')
//	Om2 - Long. Asc. Node (Om')
//	M2	- Mean anomaly (M')
//	D	- Mean elongation (D)
//	D2	- 2 * D
//	R2	- Lunar distance (Earth - Moon distance)
//	R3	- Distance ratio (Sun / Moon)
//	Bm	- Geocentric Latitude of Moon
//	Lm	- Geocentric Longitude of Moon
//	HLm	- Heliocentric longitude
//	HBm	- Heliocentric latitude
//	Ra2	- Lunar Right Ascension
//	Dec2- Declination
//

	F = range(93.2721 + 483202 * t - 0.003403 * t* t - t * t * t/3526000);
	L2 = range(218.316 + 481268 * t);
	Om2 = range(125.045 - 1934.14 * t + 0.002071 * t * t + t * t * t/450000);
	M2 = range(134.963 + 477199 * t + 0.008997 * t * t + t * t * t/69700);
	D = range(297.85 + 445267 * t - 0.00163 * t * t + t * t * t/545900);
	D2 = 2*D;
	R2 = 1 + (-20954 * dcos(M2) - 3699 * dcos(D2 - M2) - 2956 * dcos(D2)) / 385000;
	R3 = (R2 / R1) / 379.168831168831;
	Bm = 5.128 * dsin(F) + 0.2806 * dsin(M2 + F);
	Bm = Bm + 0.2777 * dsin(M2 - F) + 0.1732 * dsin(D2 - F);
	Lm = 6.289 * dsin(M2) + 1.274 * dsin(D2 -M2) + 0.6583 * dsin(D2); 
	Lm = Lm + 0.2136 * dsin(2*M2) - 0.1851 * dsin(M1) - 0.1143 * dsin(2 * F); 
	Lm = Lm +0.0588 * dsin(D2 - 2*M2) 
	Lm = Lm + 0.0572* dsin(D2 - M1 - M2) + 0.0533* dsin(D2 + M2);
	Lm = Lm + L2;
	Ra2 = datan2(dsin(Lm) * dcos(Obl) - dtan(Bm)* dsin(Obl), dcos(Lm));
	Dec2 = dasin(dsin(Bm)* dcos(Obl) + dcos(Bm)*dsin(Obl)*dsin(Lm));
	HLm = range(Lam1 + 180 + (180/Math.PI) * R3 * dcos(Bm) * dsin(Lam1 - Lm));
	HBm = R3 * Bm;

// Leon's Awesome Moon Code
// WGS84 major and minor axes
// Assume height is WGS84 height
    LatRaw = form.latitude.value;
	LongRaw = form.longitude.value;
	WGSHeightRaw = form.wgsheight.value;
// String to Float	
	WGSHeight = parseFloat(WGSHeightRaw);
	Lat = parseFloat(LatRaw);
	Long = parseFloat(LongRaw);

	MajorAxis = 6378137.0 + WGSHeight;
	MinorAxis = 6356752.32 + WGSHeight;
	XEllipse = MajorAxis * dcos(Lat);
	YEllipse = MinorAxis * dsin(Lat);
	RadiusEarth = Math.sqrt((XEllipse * XEllipse) + (YEllipse * YEllipse));

// Calculate sineAltitude
// Utilise code from the following website
// Reference: http://www.bogan.ca/astro/telescopes/coodcvtn.html
// Reference: http://www.dept.aoe.vt.edu/~lutze/AOE4134/13LocalSiderealTime.pdf

//	JD = round(days + 2451545.0, 0);
	JD = round(days + 2451545, 0);
	UT = h + min/60;
	JuDay = JD + UT/24;
//	Tut1 = (JD- 2451545.0)/36525;
	Tut1 = JD / 36525;
	UTSidTime = 100.4606184 + 36000.77005361*Tut1 + 0.00038793*Tut1*Tut1;
	UTSidModTime = UTSidTime%360;
	LocSidTime = UTSidModTime + Long;
	LocHourAngleMoon = LocSidTime - Ra2;
	LocHourAngleSun = LocSidTime - Ra1;
	SineAltitudeMoon = dsin(Lat)*dsin(Dec2) + dcos(Lat)*dcos(Dec2)*dcos(LocHourAngleMoon);
	SineAltitudeSun = dsin(Lat)*dsin(Dec1) + dcos(Lat)*dcos(Dec1)*dcos(LocHourAngleSun);
// Calculate Moon Gravity
// 

	EARTHTOMOON = 384400000;
	MASSMOON = 7.3477e+22;
	GCONST = 6.674e-11;
// Use cosine rule to calculate distance to the moon
// EARTHTOMOON^2 = RadiusEarth^2 + DISTANCEMOON^2 - 2*RadiusEarth*DISTANCEMOON*COS(90 + Altitude)
// cos(90+Altitude) = -sin(Altitude)
// Rearrange Equation
// Use Quadratic Formula
// ax^2 + bx + c = 0 

	aQuad = 1;
	bQuad = 2*RadiusEarth*SineAltitudeMoon;
	cQuad = RadiusEarth*RadiusEarth - EARTHTOMOON*EARTHTOMOON;
	DistMoon = (- bQuad + Math.sqrt(bQuad*bQuad - 4*aQuad*cQuad))/(2*aQuad);
// alternative solution is negative and therefore cannot be a solution (i.e. not a distance)
	GrossForceMoon = GCONST * MASSMOON / (DistMoon*DistMoon);
	NormalForceMoon = - GrossForceMoon*SineAltitudeMoon;
// note that the minus is to match the direction of gravity

// Calculate Sun's Gravity
	EARTHTOSUN = 149600000000;
	MASSSUN = 1.98855e+30;
	GrossForceSun = GCONST * MASSSUN / (EARTHTOSUN*EARTHTOSUN);
	NormalForceSun = - GrossForceSun*SineAltitudeSun;

// Form Values

   	form.daynumber.value = round(days, 4);
   	form.julday.value = round(days + 2451545.0, 4);
	form.SunDistance.value = round(R1, 4);
	form.SunRa.value = round(Ra1 / 15, 3);
	form.SunDec.value = round(Dec1, 2);

//
//	Write Moon numbers to form
//

	form.MoonDist.value = round(R2 * 60.268511, 2);
	form.MoonRa.value = round(Ra2 / 15, 3);
	form.MoonDec.value = round(Dec2, 2);
	
// Print Moon Gravity
	form.RadEarth.value = round(RadiusEarth, 2);
	form.SineAltMoon.value = round(SineAltitudeMoon, 4);
	form.DistanceMoon.value = round(DistMoon, 2);
	form.MoonGravity.value = round(NormalForceMoon, 6);
	
	// Print Sun Gravity

	form.SineAltSun.value = round(SineAltitudeSun, 4);
	form.SunGravity.value = round(NormalForceSun, 6);
   }

//
// this is the usual days since J2000 function
//

   function day2000(y, m, d, h) {
   var d1, b, c, greg;
   greg = y*10000 + m*100 + d;
    if (m == 1 || m == 2) {
	   y = y - 1;
	   m = m + 12;
     }
//  reverts to Julian calendar before 4th Oct 1582
//  no good for UK, America or Sweeden!

   if (greg > 15821004) {
       a = Math.floor(y/100);
       b = 2 - a  + Math.floor(a/4) }
   else {
       b = 0;
     }
   c = Math.floor(365.25 * y);
   d1 = Math.floor(30.6001 * (m + 1));
   return (b + c + d1 -730550.5 + d + h/24);
    } 

//
//	Leap year detecting function (gregorian calendar)
//  returns 1 for leap year and 0 for non-leap year
//

function isleap(y) {
	var a;
//	assume not a leap year...
	a = 0;
//	...flag leap year candidates...
	if (y % 4 == 0) a = 1;
//	...if year is a century year then not leap...
	if (y % 100 ==0 ) a = 0;
//	...except if century year divisible by 400...
	if (y % 400 == 0) a = 1;
//	...and so done according to Gregory's wishes 
	return a;
	}

//
//	Month and day number checking function
//	This will work OK for Julian or Gregorian
//	providing isleap() is defined appropriately
//	Returns 1 if Month and Day combination OK,
//	and 0 if month and day combination impossible
//
function goodmonthday(y, m, d) {
	var a, leap;
	leap = isleap(y); 
//	assume OK
	a = 1;
//	first deal with zero day number!
	if (d == 0) a = 0;
//	Sort Feburary next
	if ((m==2) && (leap ==1) && (d > 29)) a= 0;
	if ((m==2) && (d > 28) && (leap ==0))	a = 0;
//	then the rest of the months - 30 days...
	if(((m==4) || (m == 6) || (m == 9) || (m==11)) && d > 30) a = 0;
//	...31 days...	
	if (d > 31) a = 0;
//	...and so done
	return a;
	}	

//
// Trigonometric functions working in degrees - this just
// makes implementing the formulas in books easier at the
// cost of some wasted multiplications.
// The 'range' function brings angles into range 0 to 360,
// and an atan2(x,y) function returns arctan in correct
// quadrant. ipart(x) returns smallest integer nearest zero
//

function dsin(x) {
	return Math.sin(Math.PI / 180 * x)
	}

function dcos(x) {
	return Math.cos(Math.PI / 180 * x)
	}

function dtan(x) {
	return Math.tan(Math.PI / 180 * x)
	}

function dasin(x) {
	return 180/ Math.PI * Math.asin(x)
	}

function dacos(x) {
	return 180/ Math.PI * Math.acos(x)
	}

function datan(x) {
	return 180/ Math.PI * Math.atan(x)
	}

function datan2(y, x) {
	var a;
	if ((x == 0) && (y == 0)) {
		return 0;
		}
	else	{
		a = datan(y / x);
		if (x < 0) {
			a = a + 180; 
			}
		if (y < 0 && x > 0) {
			a = a + 360;
			}
		return a;
		}
	}

function ipart(x) {
	var a;
	if (x> 0) {
	    a = Math.floor(x);
		}
	else {
		a = Math.ceil(x);
		}	
	return a;
	}

function range(x) {
	var a, b
	b = x / 360;
	a = 360 * (b - ipart(b));
	if (a  < 0 ) {
		a = a + 360
		}
	return a
	}

//
// round rounds the number num to dp decimal places
// the second line is some C like jiggery pokery I
// found in an O'Reilly book which means if dp is null
// you get 2 decimal places.
//
   function round(num, dp) {
//   dp = (!dp ? 2: dp);
   return Math.round (num * Math.pow(10, dp)) / Math.pow(10, dp);
    }


   // -->
  </SCRIPT>

<META content="MSHTML 5.00.2919.6307" name=GENERATOR></HEAD>
<BODY bgColor=#ffffff>
<H2><FONT color=maroon face="arial, helvetica, homerton"><FONT color=maroon 
face="Arial, Homerton, Helvetica"><CENTER>Moon Ephemeris</CENTER></FONT></FONT></H2>
<HR>
<CENTER><B><BLOCKQUOTE>Type the UT date and time in the first box below, and then press the 
'calculate' button.<br> The program will calculate various parameters for the Moon 
at the instant you have chosen.</BLOCKQUOTE></B></CENTER> 

<!--the form below form provides all the input and output
    to these test routines --><!-- The table below holds the textboxes and labels neatly -->
<CENTER>
<TABLE border=0 cellPadding=0 cellSpacing=0 width="80%">
  <FORM name=inForm>
  <TBODY>
  <TR>
    <TD colSpan=2><B>Type in the UT date and time</B> <BR><FONT 
      size=-2><B>Date format:</B> The date 21st Feb 2000 at 23:50 is entered as 
      20000221.2350 </FONT><BR>. </TD></TR>
  <TR>
    <TD align=right>Latitude (positive is North): </TD>
    <TD><INPUT name=latitude size=14 value=-1.0>
</TD></TR>
  <TR>
    <TD align=right>Longitude (positive is East): </TD>
    <TD><INPUT name=longitude size=14 value=-42.0>
</TD></TR>
  <TR>
    <TD align=right>Height above WGS84 (m): </TD>
    <TD><INPUT name=wgsheight size=14 value=100> 
</TD></TR>
<TR>
<TR>
    <TD align=right>Enter UT date in yyyymmdd.hhmm format -: </TD>
    <TD><INPUT name=num size=14 value=20140413.0104> <INPUT onclick=doCalcs(document.inForm) type=button value=Calculate> 
</TD></TR>
  <TR>
    <TD></TD>
    <TD><BR></TD></TR>
  <TR>
    <TD colSpan=2><B>Results: Physical Ephemeris of Moon</B> <BR><FONT 
      size=-2>Selenographic longitudes towards Mare Crisium are taken as 
      positive. All figures here are based on geocentric coordinates, and 
      position angles relate to the North Celestial Pole.</FONT> 
    <TD></TD>
    <TD colSpan=2><B>Results: Time</B> 
    <TD></TD><!-- Days since J2000.0 -->
  <TR>
    <TD align=right>Days since J2000.0 -: </TD>
    <TD><INPUT name=daynumber size=14> </TD></TR><!-- Julian day number -->
  <TR>
    <TD align=right>Julian Day Number -: </TD>
    <TD><INPUT name=julday size=14> </TD></TR>
  <TR>
    <TD colSpan=2><B>Results: Sun's position</B> 
    <TD></TD>
  <TR>
    <TD align=right>Distance (AU) -: </TD>
    <TD><INPUT name=SunDistance size=14> </TD></TR>
  <TR>
    <TD align=right>Right Ascension -: </TD>
    <TD><INPUT name=SunRa size=14> </TD></TR>
  <TR>
    <TD align=right>Declination -: </TD>
    <TD><INPUT name=SunDec size=14> </TD></TR>
  <TR>
    <TD colSpan=2><B>Results: Moon's position</B> </TD></TR>
  <TR>
    <TD align=right>Distance (Earth radii) -: </TD>
    <TD><INPUT name=MoonDist size=14> </TD></TR>
  <TR>
    <TD align=right>Right Ascension -: </TD>
    <TD><INPUT name=MoonRa size=14> </TD></TR>
  <TR>
    <TD align=right>Declination -: </TD>
    <TD><INPUT name=MoonDec size=14> </TD></TR>
  <TR>
    <TD colSpan=2><B>Moon Gravity</B> </TD></TR>
  <TR>
    <TD align=right>Radius of Earth - : </TD>
    <TD><INPUT name=RadEarth size=14> </TD></TR>
  <TR>
    <TD align=right>Sine Altitude Moon-: </TD>
    <TD><INPUT name=SineAltMoon size=14> </TD></TR>
  <TR>
    <TD align=right>Distance from surface to moon -: </TD>
    <TD><INPUT name=DistanceMoon size=14> </TD></TR>
  <TR>
    <TD align=right>Moon Gravity -: </TD>
    <TD><INPUT name=MoonGravity size=14> </TD></TR>
	
  <TR>
    <TD colSpan=2><B>Sun Gravity</B> </TD></TR>
  <TR>
    <TD align=right>Sine Altitude Sun -: </TD>
    <TD><INPUT name=SineAltSun size=14> </TD></TR>
    <TD align=right>Sun Gravity -: </TD>
    <TD><INPUT name=SunGravity size=14> </TD></TR>
	<!--  Closes the form element itself --></FORM><!--  Closes the 'form' table --></TBODY></TABLE></CENTER>
<HR>
</BODY></HTML>
